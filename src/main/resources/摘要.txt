=========================设计模式的概要=========================
1、找出应用中可能需要变化的地方，把它们独立出来，不要和哪些不需要变化的代码混合在一起
2、针对接口编程，而不是针对实现编程（变量的声明类型是一个超类，通常是一个抽象类或者是一个接口）
3、为了交互对象之间的松耦合设计而努力
4、多用组合，少用继承
5、利用继承设计子类的行为，实在编译的时候静态决定的，而且所有的子类都会继承到相同的行为，然而，如果能够利用组合的做法扩展对象的行为，就可以在运行是动态的进行扩展
6、类应该对扩展开放，对修改关闭（把注意力集中在设计中最有可能改变的地方，然后应用开闭原则）
7、要依赖抽象，不要依赖具体类，不能让高层组件依赖低层，而且，不管高层或者低层组件，两者都应该依赖于抽象
8、最少知识原则：减少对象之间的交互，只留下几个紧密的对象，这个原则希望我们在设计中，不要让太多的耦合在一起，免得修改系统中的一部分，会影响到其他部分
    对于任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法（如果某对象是调用其他的方法返回的结果，那么不要调用该方法）
    a、该对象本身
    b、被当做方法的参数而传递进来的对象
    c、此方法所创建或者实例化的任何对象
    d、对象的任何组件
9、好莱坞原则：别调用我们，我们会调用你们的（高层组件对待低层组件的方式），主要解决依赖腐败（循环依赖）的问题。将决策权放在高层模块中，以便决定如何以及何时调用低层模块

=========================具体的设计模式定义=========================
1、策略模式
    定义了算法簇，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
2、观察者模式
    定义了对象之间一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新
    观察者模式中，主题是具有状态的对象，并且可以控制这些状态，就是说有该模式中，有“一个”具有状态的主题，另一方面，观察者使用了这些状态，但是这些装态并不属于他们
3、装饰者模式
    动态地就爱那个责任附加到对象上，若要扩展功能，装饰着提供了比继承更有弹性的替代方案
    装饰者可以在所委托被装饰者的行为之前或者之后，加上自己的行为，以达到特定的目的
4、工厂方法模式
    关于简单工厂
    利用静态方法定义一个简单的静态工厂，缺点是熊通过继承来改变创建方法的行为
    1解耦：由于Pizza（工厂生产出的东西）是抽象的，生产Pizza的方法orderPizza并不知道哪些实际的具体类参与进来了
    原本是由一个对象负责所有具体类的实例化，现在变成由一群子类来负责实例化，通过让子类来决定该创建的对象是什么，来达到对象创建的过程和封装的目的。
    从另外一个角度来看，在工厂方法模式中，产品类和创建者类是一个平行的关系
    定义了一个创建者对象的接口，但是由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到了子类
    在创建者中，任何其他实现了的方法，都可能使用到了这个工厂方法所制造出来的产品，但是只有子类真正实现了这个工厂方法并且来创建
5、抽象工厂模式
定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体的类，允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么
抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体的产品
工厂方法模式和抽象工厂模式区别：
a、工厂方法使用的是继承/实现，把对象的创建交给子类，抽象工厂是通过对象的组合来实现生产
（工厂方法中，通过子类来创建对象，客户只需要知道他们所使用的抽象类型就可以了，负责将客户从具体的类型中解耦，暨客户不需要知道具体的类型）
（抽象工厂是提供一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被生产的方法，把客户从所使用的具体产品中解耦，它可以把一群相关的产品集合起来）
b、抽象工厂的具体工厂经常实现工厂方法啦创建产品
    定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体的类，允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么
    抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体的产品
    工厂方法模式和抽象工厂模式区别：
    a、工厂方法使用的是继承/实现，把对象的创建交给子类，抽象工厂是通过对象的组合来实现生产
    （工厂方法中，通过子类来创建对象，客户只需要知道他们所使用的抽象类型就可以了，负责将客户从具体的类型中解耦，暨客户不需要知道具体的类型）
    （抽象工厂是提供一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被生产的方法，把客户从所使用的具体产品中解耦，它可以把一群相关的产品集合起来）
    b、抽象工厂的具体工厂经常实现工厂方法来创建产品
6、命令模式
    a、命令模式可以将“动作的请求者”从“动作的执行者”中解耦。Client只需要调用一个对外暴露的方法就好了，不需要实际关心里面具体是怎样执行的
    b、命令模式将“请求”封装成对象，以便使用不同的“请求”，队列或者日志来参数化其他对象，命令模式也支持可撤销的动作（一个命令对象通过在特定接受者上绑定一组动作来封装一个请求，但是对于其他对象来说，其他对象不知道酒精哪个接受者进行了哪些动作，只知道如果调用了对外暴露的方法，请求的目的就能达到）
    c、如果我们不想返回一个有意义的对象，那么空对象来返回也是很有用的
    d、命令模式中，在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接受者的一个或者一组动作
7、适配器模式
    a、核心就是将一个接口转换成另外一个接口，以符合客户的期望，适配器实现的接口一般都是客户期望看到的接口，换句话说就是调用者期望看到的接口
    b、适配器实现了目标接口，并且持有被是适配者的实例
    c、将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。它使用了对象组合，以修改的接口包装被适配者，优点是被适配者的任何子类，都可以搭配着适配器使用
    d、对象和类适配器，差别就是对象适配器在于利用组合的方式将请求传送给被适配者，但是类适配器是利用多继承的方式实现
    e、适配器模式与装饰者模式的区别：装饰者的话有一些新的行为或者责任要加入到设计中，扩展包装的对象的行为或者责任。但是适配器的话主要负责转换接口，对外提供客户期望的接口类型
8、外观模式
    a、通过实现提供更合理的接口的外观类，让一个复杂的子系统变得更加容易使用，外观只提供你更直接的操作，并未将原来的子系统阻隔起来
    b、外观没有“封装”子系统的类，只是提供了简化的接口，在提供简化接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用
    c、适配器模式的意图是“改变”接口以符合客户的期望，但是外观模式的意图是提供子系统的一个简化的接口。
    d、外观模式提供了一个统一的接口，用来访问子系统中的一群接口，允许我们让客户和子系统之间避免紧密的耦合。定义了一个高层的接口，让子系统更加容易使用。
    e、适配器是将一个对象包装起来以改变它的接口，装饰着将一个对象包装起来以增加新的行为和责任，而外观将一群对象包装起来以简化其接口
9、模板方法模式
    a、模板方法定义了一个算法的步骤，并且允许子类为一个或者多个步骤提供实现，抽象类专注在算法本身，具体的实现由子类来实现
    b、在方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤
    c、模板类中可以有“默认不做事的方法”，被称为hook（钩子）。这个方法是只有空的或者是默认实现。子类可以覆盖这个方法，但是不是必须覆盖的。钩子的作用是让子类能够有机会对模板方法中某些即将发生的（或者刚刚发生的）步骤做出反应
    d、当子类必须提供算法中某个方法或者步骤的时显示，需要用到抽象方法，如果算法的这个部分是可选的，就用钩子。
    e、模板方法模式中，子类选择部分算法实现，但是在策略模式中，你所组合的类需要实现整个算法。
    f、策略模式定义了一个算法家族（使用了对象组合），并让这些算法可以相互转换（set）。正因为每一个算法都被封装起来了，所以客户可以轻易的使用不同的算法。但是模板方法模式是定义一个算法的大纲，子类定义其中某些的实现步骤的内容，在超类中提供了一个基础算法，达到代码复用，允许子类指定行为
=========================具体的设计模式定义=========================