=========================设计模式的概要=========================
1、找出应用中可能需要变化的地方，把它们独立出来，不要和哪些不需要变化的代码混合在一起
2、针对接口编程，而不是针对实现编程（变量的声明类型是一个超类，通常是一个抽象类或者是一个接口）
3、为了交互对象之间的松耦合设计而努力
4、多用组合，少用继承
5、利用继承设计子类的行为，实在编译的时候静态决定的，而且所有的子类都会继承到相同的行为，然而，如果能够利用组合的做法扩展对象的行为，就可以在运行是动态的进行扩展
6、类应该对扩展开放，对修改关闭（把注意力集中在设计中最有可能改变的地方，然后应用开闭原则）
7、要依赖抽象，不要依赖具体类，不能让高层组件依赖低层，而且，不管高层或者低层组件，两者都应该依赖于抽象

=========================具体的设计模式定义=========================
1、策略模式
定义了算法簇，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
2、观察者模式
定义了对象之间一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新
观察者模式中，主题是具有状态的对象，并且可以控制这些状态，就是说有该模式中，有“一个”具有状态的主题，另一方面，观察者使用了这些状态，但是这些装态并不属于他们
3、装饰者模式
动态地就爱那个责任附加到对象上，若要扩展功能，装饰着提供了比继承更有弹性的替代方案
装饰者可以在所委托被装饰者的行为之前或者之后，加上自己的行为，以达到特定的目的
4、工厂方法模式
关于简单工厂
利用静态方法定义一个简单的静态工厂，缺点是熊通过继承来改变创建方法的行为
1解耦：由于Pizza（工厂生产出的东西）是抽象的，生产Pizza的方法orderPizza并不知道哪些实际的具体类参与进来了
原本是由一个对象负责所有具体类的实例化，现在变成由一群子类来负责实例化，通过让子类来决定该创建的对象是什么，来达到对象创建的过程和封装的目的。
从另外一个角度来看，在工厂方法模式中，产品类和创建者类是一个平行的关系
定义了一个创建者对象的接口，但是由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到了子类
在创建者中，任何其他实现了的方法，都可能使用到了这个工厂方法所制造出来的产品，但是只有子类真正实现了这个工厂方法并且来创建
5、抽象工厂模式
定义：提供一个接口，用于创建相关或依赖对象的甲组，而不需要明确指定具体的类，允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么
抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体的产品
工厂方法模式和抽象工厂模式区别：
a、工厂方法使用的是继承/实现，把对象的创建交给子类，抽象工厂是通过对象的组合来实现生产
（工厂方法中，通过子类来创建对象，客户只需要知道他们所使用的抽象类型就可以了，负责将客户从具体的类型中解耦，暨客户不需要知道具体的类型）
（抽象工厂是提供一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被生产的方法，把客户从所使用的具体产品中解耦，它可以把一群相关的产品集合起来）
b、抽象工厂的具体工厂经常实现工厂方法来创建产品
=========================具体的设计模式定义=========================